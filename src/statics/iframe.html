<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">

    <title>Kano IFrame integration</title>
    <link rel="shortcut icon" type="image/x-icon" href="statics/kano-icon-32x32.png">
    <script src="./flightpath.js"></script>
    <script src="./flightradar.js"></script>
    <script src="./post-robot.min.js"></script>
    <script src="./chroma.min.js"></script>
    <script>
      var layerIsShown = false
      var component = 'map'
      var airports

      function getGeoJsonAircraftFeature () {
        const long = 1.444209 + 0.5 * (Math.random() - 0.5)
        const lat = 43.604652 + 0.5 * (Math.random() - 0.5)
        const alt = 8519.16 + 1000 * (Math.random() - 0.5)
        const track = 360 * Math.random()
        return {
          type: 'FeatureCollection',
          features: [
            {
              type: 'Feature',
              properties: {
                callsign: 'AIB03KM',
                track: track,
                type: (Math.random() > 0.5 ? 'a380' : 'a320')
              },
              geometry: {
                type: 'Point',
                coordinates: [long, lat, alt]
              }
            }
          ]
        }
      }
      function getGeoJsonAcarsFeature (id) {
        const type = (Math.random() < 0.3 ? 'ATC' : (Math.random() > 0.7 ? 'AOC' : 'AAC'))
        let feature = {
          type: 'Feature',
          properties: {
            id,
            type,
            timestamp: new Date(Date.now() + 1000 * 60 * 60 * (Math.random() - 0.5)),
            message: `OUT 13:29Z /ZFW 113840 /FOB 13830 /TAW 127670</br>
                      /POS N50 2.3924 E8 35.1521</br>
                      /ALT 372</br>
                      /AP EDDF /GATE A 10</br>
                      /WND 08008 /OAT 17 /TAT 18`
          },
          geometry: {
            type: 'Point'
          }
        }
        return feature
      }

      function toggleGlobe() {
        component = (component === 'globe' ? 'map' : 'globe')
        return postRobot.send(kano, component)
      }
      function toggleStaticLayer(name) {
        return postRobot.send(kano, component, { command: (layerIsShown ? 'hideLayer' : 'showLayer'), args: name })
        .then(function () {
          layerIsShown = !layerIsShown
          if (layerIsShown) postRobot.send(kano, component, { command: 'zoomToLayer', args: name })
        })
      }
      function toggleBackground() {
        return postRobot.send(kano, component, { command: 'isLayerVisible', args: 'OSM Dark' })
        .then(function (result) {
          // Switch between Satellite/OSM
          postRobot.send(kano, component, { command: 'showLayer', args: (result.data ? 'OSM Bright' : 'OSM Dark') })
          return postRobot.send(kano, component, { command: 'hideLayer', args: (!result.data ? 'OSM Bright' : 'OSM Dark') })
        })
      }
      function toggleAircraftLayer(name) {
        return postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        .then(function (result) {
          if (result.data) {
            return postRobot.send(kano, component, { command: 'removeLayer', args: name })
          } else {
            return postRobot.send(kano, component, { command: 'addLayer', args: {
              name,
              type: 'OverlayLayer',
              icon: 'local_airport',
              featureId: 'callsign',
              leaflet: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                'icon-html': '<span style="display: inline-block; transformOrigin: 16px 16px; transform: rotateZ(<%= properties.track %>deg)"><img width="32px" height="32px" src="/statics/<%= properties.type %>.png"/></svg></span>',
                /* We can also use SVG
                'icon-html': '<span style="display: inline-block; transformOrigin: 16px 16px; transform: rotateZ(<%= properties.track %>deg)"><svg width="32px" height="32px" viewBox="0 0 512 512"><path fill="green" d="M281.7 311.9c.4-6.9 8.3-4.5 8.3-4.5l62 12.6 128 48.7c0-24-3.8-26.5-9.4-30.7L288 207s-4.9-60-4.9-112.9c0-24.5-11.8-78.1-27.1-78.1s-27.1 54.4-27.1 78.1c0 50.2-4.9 112.9-4.9 112.9L41.4 338c-7.1 5-9.4 7.7-9.4 30.7L160 320l61.9-12.6s7.9-2.4 8.3 4.5c.4 6.9-1.2 69.1 5.9 102.1.9 4.4-2.5 4.7-4.8 7.4l-51.9 32.8c-1.7 1.9-2.5 7.3-2.5 7.3l-1 18.5 68-16 12 32 12-32 68 16-1-18.5c.1 0-.7-5.4-2.4-7.3l-51.9-32.8c-2.3-2.7-5.7-3-4.8-7.4 6.9-33 5.5-95.2 5.9-102.1z"/></svg></span>',
                */
                'icon-anchor': [16, 16],
                'marker-size': 32,
                'icon-class': '',
                template: ['icon-html'],
                popup: { pick: [] },
                tooltip: {
                  template: '<%= properties.callsign %>'
                }
              },
              cesium: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                'marker-symbol': 'airport',
                'marker-color': '#57D824',
                entityStyle: {
                  model: {
                    type: 'Cesium.ModelGraphics',
                    options: {
                      uri: '/statics/<%= properties.type %>.glb',
                      minimumPixelSize: 64,
                      scale: 0.1
                    },
                  },
                  // Orientation as heading, pitch, roll
                  orientation: '<%= properties.track %>,0,0',
                  localFrameAxes: ['east', 'north'],
                  template: ['model.options.uri', 'orientation']
                },
                popup: { pick: [] },
                tooltip: {
                  template: '<%= properties.callsign %>'
                }
              }
            }})
            .then(function () { updateAircraftLayer(name) })
          }
        })
      }
      function updateAircraftLayer(name) {
        const geoJson = getGeoJsonAircraftFeature()
        const long = geoJson.features[0].geometry.coordinates[0]
        const lat = geoJson.features[0].geometry.coordinates[1]
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, geoJson] })
        .then(function () {
          // Use zoom level or altitude depending on mode
          return postRobot.send(kano, component, { command: 'center', args: [long, lat, (component === 'globe' ? 10000 : 12)] })
        })
      }
      function toggleMetarTafLayer(name) {
        return postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        .then(function (result) {
          if (result.data) {
            return postRobot.send(kano, component, { command: 'removeLayer', args: name })
          } else {
            return postRobot.send(kano, component, { command: 'addLayer', args: {
              name,
              type: 'OverlayLayer',
              icon: 'wb_sunny',
              featureId: 'ICAO',
              leaflet: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                container: 'markerClusterGroup',
                /* We can use SVG
                'icon-html': '<svg height="16" width="16"><circle cx="8" cy="8" r="6" fill-opacity="0.5" stroke-width="0"\
                                fill="<% if (properties.visibility < 75) { %>#000000<% }\
                                      else if (properties.visibility < 300) { %>#d20200<% }\
                                      else if (properties.visibility < 1500) { %>#f9b40f<% }\
                                      else if (properties.visibility < 3000) { %>#eef52f<% }\
                                      else { %>#33c137<% } %>"/>\
                              </svg>',
                'icon-anchor': [8, 8],
                'marker-size': 16,
                'icon-class': '',
                template: ['icon-html'],
                */
                /* We can use font-awesome icons
                'icon-classes': 'fa fa-sun-o',
                'icon-color': '#000000',
                'icon-x-offset' : -2,
                'icon-y-offset' : 0,
                'marker-color': `<% if (properties.visibility < 75) { %>#000000<% }
                                    else if (properties.visibility < 300) { %>#d20200<% }
                                    else if (properties.visibility < 1500) { %>#f9b40f<% }
                                    else if (properties.visibility < 3000) { %>#eef52f<% }
                                    else { %>#33c137<% } %>`,
                template: ['marker-color'],
                */
                /* We can use images
                'marker-symbol': `<% if (properties.visibility < 75) { %>/statics/windyblack.png<% }
                                    else if (properties.visibility < 300) { %>/statics/windyred.png<% }
                                    else if (properties.visibility < 1500) { %>/statics/windyorange.png<% }
                                    else if (properties.visibility < 3000) { %>/statics/windyyellow.png<% }
                                    else { %>/statics/windygreen.png<% } %>`,
                'marker-size': [24, 30],
                template: ['marker-symbol'],
                */
                /* We can use HTML */
                'icon-html': `<b style="display: inline-block; color:#000;
                                text-shadow:-1px -1px 0 #FFF,1px -1px 0 #FFF,-1px 1px 0 #FFF,1px 1px 0 #FFF;">
                                <%= properties.ICAO %>
                              </b>
                              <img style="display: inline-block;" width="24px" height="30px" src="
                                <% if (properties.visibility < 75) { %>/statics/windyblack.png<% }
                                  else if (properties.visibility < 300) { %>/statics/windyred.png<% }
                                  else if (properties.visibility < 1500) { %>/statics/windyorange.png<% }
                                  else if (properties.visibility < 3000) { %>/statics/windyyellow.png<% }
                                  else { %>/statics/windygreen.png<% } %>"/>
                              `,
                'icon-class': '',
                'icon-anchor': [12, 32],
                template: ['icon-html'],
                popup: { pick: [] },
                tooltip: {
                  template: '<b>METAR</b></br><%= properties.metar %></br><b>TAF</b></br><%= properties.taf %>'
                }
              },
              cesium: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                cluster: {
                  pixelRange: 50
                },
                entityStyle: {
                  billboard: {
                    scale: 0.5,
                    image: `<% if (properties.visibility < 75) { %>/statics/windyblack.png<% }
                              else if (properties.visibility < 300) { %>/statics/windyred.png<% }
                              else if (properties.visibility < 1500) { %>/statics/windyorange.png<% }
                              else if (properties.visibility < 3000) { %>/statics/windyyellow.png<% }
                              else { %>/statics/windygreen.png<% } %>`,
                    color: `Cesium.Color.<% if (properties.visibility < 75) { %>BLACK<% }
                              else if (properties.visibility < 300) { %>ORANGERED<% }
                              else if (properties.visibility < 1500) { %>GOLD<% }
                              else if (properties.visibility < 3000) { %>YELLOW<% }
                              else { %>LIMEGREEN<% } %>"/>`
                  },
                  template: ['billboard.image', 'billboard.color']
                },
                popup: { pick: [] },
                tooltip: {
                  template: 'METAR\n<%= properties.metar %>\nTAF\n<%= properties.taf %>'
                }
              }
            }})
            .then(function () { return updateMetarTafLayer(name) })
            .then(function () { setTimeout(() => postRobot.send(kano, component, { command: 'zoomToLayer', args: name }), 1000) })
          }
        })
      }
      function updateMetarTafLayer(name) {
        // Setup random visibility on some airports
        airports.features.forEach(function(airport) {
          const visibility = 5000 * Math.random()
          airport.properties.visibility = visibility
          airport.properties.metar = 'KAUS 092135Z 26018G25KT 8SM -TSRA BR SCT045CB BKN060 OVC080 30/21 A2992'
          airport.properties.taf = 'KOKC 051130Z 051212 14008KT 5SM BR BKN030 TEMPO 1316 1 1/2SM BR'
        })
        // Filter airports as all don't have METAR/TAF information
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, { type: 'FeatureCollection', features: airports.features.slice(0, 100) }] })
      }
      function toggleAcarsLayer(name) {
        return postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        .then(function (result) {
          if (result.data) {
            return postRobot.send(kano, component, { command: 'removeLayer', args: name })
          } else {
            return postRobot.send(kano, component, { command: 'addLayer', args: {
              name,
              type: 'OverlayLayer',
              icon: 'message',
              featureId: 'id',
              leaflet: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                'marker-type': 'circleMarker',
                'radius': 6,
                'stroke-width': 0,
                'fill-opacity': 0.75,
                'fill-color': `<% if (properties.type === 'ATC') { %>#000000<% }
                                    else if (properties.type === 'AOC') { %>#f9b40f<% }
                                    else { %>#33c137<% } %>`,
                template: ['fill-color'],
                popup: { pick: [] },
                tooltip: {
                  template: '<b><%= properties.timestamp.toISOString() %></b></br><%= properties.message %>'
                },
                // Use higher value than default overlays to ensure messages are always on top of flightpath
                // (see https://leafletjs.com/reference-1.4.0.html#map-overlaypane)
                zIndex: 401
              },
              cesium: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                'marker-symbol' : 'circle',
                entityStyle: {
                  billboard: {
                    color: `Cesium.Color.<% if (properties.type === 'ATC') { %>BLACK<% }
                              else if (properties.type === 'AOC') { %>ORANGE<% }
                              else { %>LIMEGREEN<% } %>`
                  },
                  template: ['billboard.color']
                },
                popup: { pick: [] },
                tooltip: {
                  template: '<%= properties.timestamp.toISOString() %>\n<%= properties.message %>'
                }
              }
            }})
            .then(function () { return updateAcarsLayer(name) })
            .then(function () { setTimeout(() => postRobot.send(kano, component, { command: 'zoomToLayer', args: name }), 1000) })
          }
        })
      }
      function updateAcarsLayer(name) {
        // Setup random messages
        let acars = { type: 'FeatureCollection', features: [] }
        for (let i = 0; i < flightpath.length; i++) {
          let feature = getGeoJsonAcarsFeature(i)
          feature.geometry.coordinates = flightpath[i]
          acars.features.push(feature)
        }
        // Filter airports as all don't have METAR/TAF information
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, acars] })
      }
      function toggleFlightpathLayer(name) {
        return postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        .then(function (result) {
          if (result.data) {
            return postRobot.send(kano, component, { command: 'removeLayer', args: name })
          } else {
            return postRobot.send(kano, component, { command: 'addLayer', args: {
              name,
              type: 'OverlayLayer',
              icon: 'timeline',
              featureId: 'id',
              leaflet: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                popup: { pick: [] },
                tooltip: {
                  template: '<%= properties.message %>'
                }
              },
              cesium: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                popup: { pick: [] },
                tooltip: {
                  template: '<%= properties.message %>'
                },
                entityStyle: {
                  polyline: {
                    clampToGround: false
                  }
                }
              }
            }})
            .then(function () { return updateFlightpathLayer(name) })
            .then(function () { postRobot.send(kano, component, { command: 'zoomToLayer', args: name }) })
          }
        })
      }
      function updateFlightpathLayer(name) {
        // Setup random path
        let coordinates = flightpath.map(function(point) {
          return [ point[0] + 0.05 * (Math.random() - 0.5),
                   point[1] + 0.05 * (Math.random() - 0.5),
                   10000 * Math.random() ]
        })
        let path = { type: 'FeatureCollection', features: [] }
        const middle = parseInt(coordinates.length / 2)
        path.features.push({
          type: 'Feature',
          properties: { id: 0, message: 'ADS-B KO', stroke: Math.random() > 0.5 ? '#000000' : '#FFFF00', weight: 1 + 5 * Math.random() },
          geometry: { type: 'LineString', coordinates: coordinates.slice(0, middle + Math.ceil(flightpath.length % 2))}
        })
        path.features.push({
          type: 'Feature',
          properties: { id: 1, message: 'ADS-B OK', stroke: Math.random() > 0.5 ? '#FF00FF' : '#00FFFF', weight: 1 + 5 * Math.random(),  'dash-array': '20, 20' },
          geometry: { type: 'LineString', coordinates: coordinates.slice(middle, flightpath.length)}
        })
        // Filter airports as all don't have METAR/TAF information
        return postRobot.send(kano, component, { command: 'updateLayer', args: [name, path] })
      }
      function toggleGradientFlightpathLayer(name) {
        return postRobot.send(kano, component, { command: 'isLayerVisible', args: name })
        .then(function (result) {
          if (result.data) {
            return postRobot.send(kano, component, { command: 'removeLayer', args: name })
          } else {
            return postRobot.send(kano, component, { command: 'addLayer', args: {
              name,
              type: 'OverlayLayer',
              icon: 'timeline',
              featureId: 'id',
              leaflet: {
                type: 'path',
                realtime: true,
                isVisible: true,
                popup: { pick: [] },
                tooltip: {
                  template: '<%= properties.message %>'
                }
              },
              cesium: {
                type: 'geoJson',
                realtime: true,
                isVisible: true,
                popup: { pick: [] },
                tooltip: {
                  template: '<%= properties.message %>'
                }
              }
            }})
            .then(function () { 
              return updateGradientFlightpathLayer(name) 
            })
            .then(function () { postRobot.send(kano, component, { command: 'zoomToLayer', args: name }) })
          }
        })
      }
      function updateGradientFlightpathLayer(name) {
        let colorramp = chroma.scale([
          'white',  //0
          'yellow', // 2000
          'yellow', // 3000
          'green',  // 5000 
          'green',  // 8000
          'lightblue', // 10000
          'lightblue', // 18000
          'navy', // 20000
          'navy', // 33000
          'purple', //35000
          'purple']).domain([0, 2000, 3000, 5000, 8000, 10000, 18000, 20000, 33000, 35000, 50000])
        let gradient = []
        let path = flightradar.features[0]
        let coords = path.geometry.coordinates
        for (let i=0; i < coords.length; ++i) {
          let height = path.properties[i].altitude.feet
          let color = colorramp(height).hex()
          gradient.push(color)
        }
        path.properties = { gradient, weight: 8 }      
        return postRobot.send(kano, component, { command: 'updatePaths', args: [path] })
      }
    </script>
  </head>
  <body style="background-color: grey">
    <table style="margin-left:auto;margin-right:auto;">
      <thead>
        <tr><th colspan="2"><h1>Kano IFrame Integration Sample</h1></th></tr>
      </thead>
      <tbody>
      <tr>
        <td style="text-align:center;">
          <button type="button" onclick="toggleGlobe()">Switch 2D/3D</button></br>
          <button type="button" onclick="toggleBackground()">Switch background</button></br>
          <button type="button" onclick="toggleStaticLayer('Airports')">Switch airports</button></br>
          <button type="button" onclick="toggleMetarTafLayer('METAR')">Switch METAR</button></br>
          <button type="button" onclick="updateMetarTafLayer('METAR')">Update METAR</button></br>
          <button type="button" onclick="toggleAircraftLayer('Aircraft')">Switch aircraft</button></br>
          <button type="button" onclick="updateAircraftLayer('Aircraft')">Update aircraft</button></br>
          <button type="button" onclick="toggleAcarsLayer('ACARS')">Switch ACARS</button></br>
          <button type="button" onclick="updateAcarsLayer('ACARS')">Update ACARS</button></br>
          <button type="button" onclick="toggleFlightpathLayer('Flightpath')">Switch flightpath</button></br>
          <button type="button" onclick="updateFlightpathLayer('Flightpath')">Update flightpath</button></br>
          <button type="button" onclick="toggleGradientFlightpathLayer('GradientFlightpath')">Switch gradient flightpath</button></br>
        </td>
        <td>
          <iframe id="kano" title="Kano" allow="geolocation *" style="width: 1024px; height: 768px;" src="/">
          </iframe>
        </td>
      </tr>
      </tbody>
    </table>
    <script>
      var kano = document.getElementById('kano').contentWindow
      postRobot.send(kano, 'getLocalStorage')
      .then(function(event) {
        let localStorage = event.data
        localStorage.setItems({
          'kano-jwt': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJkZXYua2FsaXNpby54eXoiLCJpc3MiOiJrYWxpc2lvIiwiZXhwIjoxNTg0MDE1Mjg0fQ.oOPo_7lPMFgH6dBUtSnNs3w4h-DwwCSLdg9yMF0YU18'
        })
      })

      postRobot.on('map-ready', () => {
        postRobot.send(kano, component, { command: 'getFeaturesFromLayer', args: 'Airports' })
        .then(function (result) { airports = result.data })
      })
      postRobot.on('globe-ready', () => {
        // Whatever
      })
      postRobot.on('click', (event) => {
        if (event.data.layer.name === 'ACARS') {
          alert('ACARS message clicked')
        }
      })
    </script>
  </body>
</html>
